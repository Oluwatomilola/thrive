# Hiro Chainhooks — 20-step plan

This document lists the 20 actionable steps to extend the Stacks staking dApp into a real-time, event-driven application using Hiro Chainhooks.

1. Research Hiro Chainhooks

   - Read Chainhooks docs, identify webhook payloads, event types supported, and auth methods; choose approach for subscriptions.

2. Audit staking contract events

   - Inspect `contracts/message-board.clar` and any staking contracts to determine which events/logs (staking, unstaking, transfers) to subscribe to.

3. Design event schema

   - Design internal event object shape (type, txid, principal, amount, timestamp, metadata) and DB schema for storing events.

4. Choose backend stack

   - Select lightweight backend framework (Node.js + Express or Fastify) and runtime environment; plan for local dev (ngrok) and production hosting.

5. Scaffold backend service

   - Create project skeleton with endpoints for Chainhooks, health check, and admin webhooks; add env var config and TypeScript support.

6. Implement webhook verification

   - Implement verification of incoming Chainhook requests (shared secret / signature) and reject invalid requests.

7. Subscribe to relevant on-chain events

   - Create Chainhook subscription requests (via Hiro API or dashboard) for staking/unstaking events and confirm delivery to webhook endpoint.

8. Event handler implementation

   - Parse incoming webhook payloads, map to internal event schema, validate fields, and enqueue for processing.

9. Persist events in DB

   - Add migrations and persistence (SQLite/Postgres) to store events and maintain idempotency (unique txid constraints).

10. Add idempotency and retries

    - Implement idempotent processing and retry/backoff logic for transient failures to ensure reliable event handling.

11. Real-time push layer

    - Implement WebSocket or Server-Sent Events (SSE) endpoint to push processed events to connected clients in real time.

12. Integrate frontend to receive events

    - Update frontend to open WS/SSE connection, handle incoming events, and update UI state reactively for staking/unstaking.

13. Activity feed UI components

    - Design and add UI components to display live activity feed, pending confirmations, and historical events with filters.

14. Link on-chain tx→UI flows

    - Add optimistic UI updates for local transactions and reconcile with chainhook-delivered confirmed events.

15. Add security & auth

    - Protect admin endpoints, secure webhook secrets in env, and implement rate limiting and basic monitoring.

16. Testing event handlers

    - Write unit and integration tests for parsing, idempotency, DB persistence, and WS broadcast logic.

17. CI and linting

    - Add CI workflow (GitHub Actions or other) to run tests, lint, and type-check on PRs to the new branch.

18. Deployment plan

    - Prepare deployment (Vercel/Heroku/AWS) with required env vars, DB provisioning, and HTTPS webhook URL for Chainhooks.

19. Register Chainhooks in Hiro dashboard

    - Register the webhook URL and subscribe to contract events on Hiro Chainhooks dashboard; validate delivery and signing.

20. E2E testing and documentation
    - Run end-to-end tests, document setup, environment variables, developer runbook, and troubleshooting steps.

---

Generated by GitHub Copilot assistant as the initial project plan.
